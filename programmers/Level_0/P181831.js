// P181831: 특별한 이차원 배열 2
function solution(arr) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr[i].length; j++) {
      if (arr[i][j] !== arr[j][i]) return 0;
    }
  }
  return 1;
}

console.log(
  solution([
    [5, 192, 33],
    [192, 72, 95],
    [33, 95, 999],
  ])
);
console.log(
  solution([
    [19, 498, 258, 587],
    [63, 93, 7, 754],
    [258, 7, 1000, 723],
    [587, 754, 723, 81],
  ])
);

/**
 * n*n 크기의 이차원 배열 arr이 매개변수로 주어질 때, arr이 다음을 만족하면 1, 아니라면 0을 반환
 * ==> 0 ≤ i, j < n인 정수 i, j에 대하여 arr[i][j] = arr[j][i]
 *
 * - 뭔가 있나 없나 걸러내는거니까 filter를 쓸 수 있을 것 같은데...
 */

/**
 * 나는 굳이 선언적일 필요가 있을까? 싶어서 그냥 for 반복문을 사용했다.
 * 근데 보니 every로 푸는 풀이가 있었다.
 * `return arr.every((r, i) => r.every((_, j) => arr[i][j] === arr[j][i])) ? 1 : 0;`
 * filter를 반복해서 사용하는걸 생각하기는 했는데, 그렇게 되면 모든 원소를 순회하고 조건을 만족하지 않는다면 0이 반환되기 때문에 비효율적이라 생각했다.
 * (중간에라도 0 리턴하고 끝낼 수 있으니까)
 * ==> 알아보니까 every도 중간에 조건에 맞지 않으면 조기 종료한다고 한다.
 * 이렇게 생각하면 가독성만 조금 떨어지지 every를 사용하는 것도 좋은 방법이 될 수 있다 생각한다.
 */
