// P12982: 예산
function solution(d, budget) {
  const sortedD = d.sort((a, b) => a - b);
  while (budget < sortedD.reduce((a, c) => a + c, 0)) {
    d.pop();
  }
  return d.length;
}

console.log(solution([1, 3, 2, 5, 4], 9));

/**
 * 예산 내에서 최대한 많은 부서의 물품을 구매할 수 있도록 함. 각 부서가 신청한 금액 모두를 지원. (부분 지원 x)
 * 최대 몇 개의 부서에 지원할 수 있는지 return
 * 각 부서의 순서나 우선순위는 없음. 최대한 모든 금액을 사용하면서 지원할 수 있는 부서의 개수를 반환해라.
 *
 * (1) 예산이 적은 수부터 오름차순으로 정렬하고 차례대로 조합한다 => 최소 숫자의 조합만으로 안될 수 있음.
 * (2) 최대 개수부터 조합하고 각 조합의 합이 budget이랑 같은지 검사한다 => 시간이 너무 오래걸리고, 항상 예산을 다 쓰지 않을 수 있음
 *
 *
 * 10시 44분 ~ 11시 22분
 */

/**
 * 결국 인터넷에 다른 언어 풀이를 검색해서 풀었다.
 * 오름차순으로 정렬하고 조합해서 푼다는 첫 접근은 맞았는데.. 나는 왜 중간에 안된다 생각했을까?
 *
 * 지금 같은 방식을 그리디 알고리즘이라고 한다. (이것도 안 떠올린건 아니지만...)
 * 그리디가 성립하는 조건은 아래 3가지이다.
 * 1. 현재 최선 선택이
 * 2. 전체에서 최선 선택을 항상 보장한다.
 * 3. 이를 보장하는 구조적 특징(단조성, 교환성)이 있어야 한다.
 *  - 단조성: 유리한 선택을 했을 때 이후의 선택 가능성이 줄어들지 않아야 한다.
 *  - 교환성: 비효율적인 선택이 있으면 항상 더 효율적인 선택으로 교체할 수 있어야 하고, 그 교체가 최적성을 깨뜨리지 않아야 한다.
 *
 * 내가 이 풀이가 안된다고 생각했던 지점은 조합의 각 요소만 생각했기 떄문이다.
 * 예를 들어 [1,2,3,4,5]와 9가 있을 때, 최대 예산 소요는 [1,3,5]이다.
 * 하지만 이 문제는 [1,3,5]를 원한게 아니라 '3팀'이라는 최대 조합 개수를 원했다.
 * 그렇기 때문에 지금 코드로 [1,2,3]만 남더라도 결국 '3팀이 지원 받을 수 있다'는 정답이 가능한 것이다.
 * **즉 문제는 예산을 최대한 쓰는 목표보다, 몇 개의 부서에 지원할 수 있는가? <- 포인트이다.**
 *
 * 내가 헷갈렸던 지점은 작은 숫자 조합만이 답이 아닐 수 있다고 생각했지만, 항상 작은 숫자를 포함하는 최적 조합이 존재한다는 것을 까먹었기 때문일 것이다.
 *
 * 추가적으로, 그리디로 풀 수 없는 문제라면 (1) 완전 탐색 / (2) 동적 계획법, DP 와 같은 방법을 사용해야 한다.
 */
