// P12906: 같은 숫자는 싫어
function solution(arr) {
  const stack = [];

  for (let num of arr) {
    if (stack.length == 0) stack.push(num);
    if (stack[stack.length - 1] !== num) stack.push(num);
  }

  return stack;
}

console.log(solution([1, 1, 3, 3, 0, 1, 1]));

/**
 * 배열 arr의 각 원소는 숫자 0부터 9까지 이루어져 있다.
 * 배열 arr에서 연속적으로 나타나는 숫자는 하나만 남기고 전부 제거하려고 한다.
 * 제거된 후 남은 수들을 반환할 때는 배열 arr의 원소들의 순서를 유지해야 한다.
 * => 배열에서 연속되는 숫자는 제거하고 남은 수들을 return
 */

/**
 * 문제 카테고리는 스택/큐였다.
 * 모든 중복 수를 없애는게 아니라 연속되는 숫자만 합쳐야 하니까 Set은 못 쓸듯.
 * 스택을 사용해서 마지막 원소가 arr의 현재 인덱스와 같다면 넘기기?
 * -> 이 방법은 아니었던 걸로.
 * 근데 큐보단 스택이 맞을것 같은데... 근데 문제에서 순서 유지하라고 했으니까 큐이려나?
 * 큐라고 해보자.
 * 일단 큐 하나를 두고, arr을 돌면서 같은 숫자가 나오는 만큼 하나의 큐를 가짐.
 */

/**
 * ... 아니 내 머릿속으로는 오래 걸릴 일이 없는데 계속 효율성 검사에서 탈락했다. (결국 맨 마지막 인덱스만 사용하니까)
 * 그 이유는 arr.at(-1)을 써서...
 * Array.prototype.at() : 정숫값을 받아 해당 인덱스에 있는 항목을 반환하며, 양수와 음수를 모두 사용할 수 있다.
 *
 * 두 방식의 차이점은 “**메소드 호출 오버헤드 vs 단순 인덱스 접근**”이다.
 * mdn 공식 문서에서도 `at()`이 성능 저하의 문제가 있다는 얘기는 딱히 못봤고, gpt도 명확한 근거는 없다고는 하지만…(?)
 * `at()`은 결국 메서드를 호출하는 방식이라서 bracket-표기법보다 느릴 수 있다고 한다. (브라우저나 JS 엔진마다 구현 방식이 다를 수 있으니까)
 * `at()`이 도입된 이유는 가독성과 편의성 때문이다.
 * 그러니 성능이 중요한 순간에는 bracket-표기법을 사용하자.
 */

/**
 * 다른 사람 풀이를 보니 filter로 풀기도 했다.
 * `return arr.filter((val,index) => val != arr[index+1]);`
 * 이전 인덱스와 비교해서 같지 않은 것만,,, 똑똑하시네 다들.
 */
